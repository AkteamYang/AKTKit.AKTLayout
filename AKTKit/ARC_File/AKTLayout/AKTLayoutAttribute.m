//
//  AKTLayoutAttribute.c
//  AKTLayout
//
//  Created by YaHaoo on 16/4/15.
//  Copyright © 2016年 YaHaoo. All rights reserved.
//

#import "AKTLayoutAttribute.h"
// import-<frameworks.h>

// import-"models.h"
#import "UIView+AKTLayout.h"
#import "AKTLayoutShell.h"
#import "AKTPublic.h"
// import-"views & controllers.h"

//--------------------Structs statement, globle variables...--------------------
typedef struct {
    float top, left, bottom, right, width, height, whRatio, centerX, centerY;
}AKTLayoutParam;
typedef AKTLayoutParam *AKTLayoutParamRef;
//-------------------- E.n.d -------------------->Structs statement, globle variables...

#pragma mark - function definition
//|---------------------------------------------------------
/**
 *  Create a layout attribute item according to the attribute item type.
 *  根据类型创建布局项
 *
 *  @param attribute Layout attribute.
 *  @param attribute 布局对象
 *  @param itemType  Attribute item type.
 *  @param itemType  布局项类型
 *
 */
void createItem(AKTAttributeItemType itemType);

/**
 *  移除无效的布局信息
 *
 *  @param attributeRef
 */
void removeInvalidAttributeItemFromAttribute(AKTLayoutAttributeRef attributeRef, bool fromDynamic);

/**
 *  如果配置了edge，计算frame
 */
CGRect calculateRectWithEdgeFromAttribute(UIView *bindView, AKTLayoutAttributeRef attributeRef, UIView *referenceView, AKTAttributeItemRef itemRef, UIEdgeInsets edgeInset, BOOL isDynamic);
/*
 * Parse layout item to layout param
 */
void parseItem(AKTAttributeItemRef itemRef, AKTLayoutParamRef paramRef, UIView *bindView);

/*
 * Rect generated by infor in param
 */
CGRect calculateRect(AKTLayoutParamRef paramRef, AKTLayoutAttributeRef attributeRef);

/*
 * According to param, calculate the size of frame in horizontal direction. When you call the method, please ensure there were no redundant configurations in param.
 * In one direction two configurations in addition to "whRatio" is enough to calculate the frame in that direction. WhRation will be convert to the configuration of width or height
 * @oRect : The frame of the view which will be layout according to the reference view was got before layout
 */
CGRect horizontalCalculation(AKTLayoutParamRef paramRef, CGRect oRect);

/*
 * According to param, calculate the size of frame in vertical direction. When you call the method, please ensure there were no redundant configurations in param.
 * In one direction two configurations in addition to "whRatio" is enough to calculate the frame in that direction. WhRation will be convert to the configuration of width or height
 * @oRect : The frame of the view which will be layout according to the reference view was got before layout
 */
CGRect verticalCalculation(AKTLayoutParamRef paramRef, CGRect oRect);

void getAllOfTheReferencedView(AKTLayoutAttributeRef attributeRef, UIView *bindview);

void getWHRatio(AKTAttributeItemRef itemRef, AKTLayoutParamRef paramRef);

void setSizeIfExist(AKTAttributeItemRef itemRef, AKTLayoutParamRef paramRef, bool *hasSize);

/*
 * The param has no configuration for whRatio, return the rect
 */
CGRect rectNoWhRatio(AKTLayoutParamRef paramRef, AKTLayoutAttributeRef attributeRef);

/*
 * The param has the configuration for whRatio, return the rect
 */
CGRect rectWhRatio(AKTLayoutParamRef paramRef, AKTLayoutAttributeRef attributeRef);

#pragma mark - life cycle
//|---------------------------------------------------------
/**
 *  Initialize AKTLayoutAttribute.
 *  初始化
 *
 *  @param view      The view need to be layout
 *  @param view      需要被布局的视图
 */
void aktLayoutAttributeInit(UIView *view) {
    attributeRef_global->itemCountForStatic = 0;
    attributeRef_global->itemCountForDynamic = 0;
    attributeRef_global->bindView = (__bridge const void *)(view);
    attributeRef_global->currentLayoutInfoDidCheck = false;
    attributeRef_global->layoutInfoTag = LONG_MAX;
    attributeRef_global->blockCountForDynamic = 0;
    attributeRef_global->layoutDynamicContextBegin = false;
    attributeRef_global->validLayoutAttributeInfo = true;
    attributeRef_global->viewReferenced = 0;
}

/**
 *  AKTLayoutAttribute deallock
 *
 *  @param attributeRef
 */
void aktLayoutAttributeDealloc(AKTLayoutAttributeRef attributeRef, bool freeMemory) {
    for (int i=0; i<attributeRef->blockCountForDynamic; i++) {
        AKTDynamicLayoutBlock *block = attributeRef->blockArrayForDynamic+i;
        CFBridgingRelease(block->conditionBlock);
        CFBridgingRelease(block->attributeBlock);
    }
    if(freeMemory) free(attributeRef);
}

AKTLayoutParam initializedParamInfo() {
    return (AKTLayoutParam){
        .top     = FLT_MAX,
        .left    = FLT_MAX,
        .bottom  = FLT_MAX,
        .right   = FLT_MAX,
        .width   = FLT_MAX,
        .height  = FLT_MAX,
        .whRatio = FLT_MAX,
        .centerX = FLT_MAX,
        .centerY = FLT_MAX
    };
}

#pragma mark - create item
//|---------------------------------------------------------
/**
 *  Create layout attribute item.
 *  创建布局项.
 *
 */
void __akt__create__top() {
    createItem(AKTAttributeItemType_Top);
}

void __akt__create__left() {
    createItem(AKTAttributeItemType_Left);
}

void __akt__create__bottom() {
    createItem(AKTAttributeItemType_Bottom);
}

void __akt__create__right() {
    createItem(AKTAttributeItemType_Right);
}

void __akt__create__width() {
    createItem(AKTAttributeItemType_Width);
}

void __akt__create__height() {
    createItem(AKTAttributeItemType_Height);
}

void __akt__create__whRatio() {
    createItem(AKTAttributeItemType_WHRatio);
}

void __akt__create__centerX() {
    createItem(AKTAttributeItemType_CenterX);
}

void __akt__create__centerY() {
    createItem(AKTAttributeItemType_CenterY);
}

void __akt__create__centerXY() {
    createItem(AKTAttributeItemType_CenterXY);
}

void __akt__create__edge() {
    bool isDynamic = attributeRef_global->layoutDynamicContextBegin;
    NSInteger count = isDynamic? attributeRef_global->itemCountForDynamic:attributeRef_global->itemCountForStatic;
    // Check whether out of range
    if (count==kItemMaximum) {
        UIView *view = (__bridge UIView *)(attributeRef_global->bindView);
        NSString *description = [NSString stringWithFormat:@"> %@: Out of the range of attributeItem array(%@).\n> \"attributeItem\"数组越界(%@)",isDynamic? @"dynamic part":@"static part", view.aktName, isDynamic? @"动态部分":@"静态部分"];
        NSString *sugget = [NSString stringWithFormat:@"> You add too much reference. For more details, please refer to the error message described in the document. 添加了过多的参照，详情请参考错误信息描述文档"];
        __aktErrorReporter(301, description, sugget);
        return ;
    }
    // 存入布局数据
    AKTAttributeItemRef itemRef;
    if(isDynamic){
        itemRef = attributeRef_global->itemArrayForDynamic+attributeRef_global->itemCountForDynamic;
        aktAttributeItemInit(itemRef);
        attributeRef_global->itemCountForDynamic++;
        
    }else{
        itemRef = attributeRef_global->itemArrayForStatic+attributeRef_global->itemCountForStatic;
        aktAttributeItemInit(itemRef);
        attributeRef_global->itemCountForStatic++;
    }
    // Set bindView
    itemRef->bindView = attributeRef_global->bindView;
    // Add itemType to item
    itemRef->configuration.referenceEdgeInsert = UIEdgeInsetsMake(0, 0, 0, 0);
    return ;
}

void __akt__create__size() {
    BOOL isDynamic = attributeRef_global->layoutDynamicContextBegin;
    NSInteger count = isDynamic? attributeRef_global->itemCountForDynamic:attributeRef_global->itemCountForStatic;
    // Check whether out of range
    if (count==kItemMaximum) {
        UIView *view = (__bridge UIView *)(attributeRef_global->bindView);
        NSString *description = [NSString stringWithFormat:@"> %@: Out of the range of attributeItem array(%@).\n> \"attributeItem\"数组越界(%@)",isDynamic? @"dynamic part":@"static part", view.aktName, isDynamic? @"动态部分":@"静态部分"];
        NSString *sugget = [NSString stringWithFormat:@"> You add too much reference. For more details, please refer to the error message described in the document. 添加了过多的参照，详情请参考错误信息描述文档"];
        __aktErrorReporter(301, description, sugget);
        return;
    }
    // 存入布局数据
    AKTAttributeItemRef itemRef;
    if(isDynamic){
        itemRef = attributeRef_global->itemArrayForDynamic+attributeRef_global->itemCountForDynamic;
        aktAttributeItemInit(itemRef);
        attributeRef_global->itemCountForDynamic++;
        
    }else{
        itemRef = attributeRef_global->itemArrayForStatic+attributeRef_global->itemCountForStatic;
        aktAttributeItemInit(itemRef);
        attributeRef_global->itemCountForStatic++;
    }
    // Set bindView
    itemRef->bindView = attributeRef_global->bindView;
    // Add itemType to item
    itemRef->configuration.reference.referenceSize = CGSizeMake(0, 0);
    return;
}

/**
 *  Create a layout attribute item according to the attribute item type.
 *  根据类型创建布局项
 *
 *  @param itemType  Attribute item type.
 *  @param itemType  布局项类型
 *
 */
void createItem(AKTAttributeItemType itemType) {
    BOOL isDynamic = attributeRef_global->layoutDynamicContextBegin;
    NSInteger count = isDynamic? attributeRef_global->itemCountForDynamic:attributeRef_global->itemCountForStatic;
    // Check whether out of range
    if (count==kItemMaximum) {
        UIView *view = (__bridge UIView *)(attributeRef_global->bindView);
        NSString *description = [NSString stringWithFormat:@"> %@: Out of the range of attributeItem array(%@).\n> \"attributeItem\"数组越界(%@)",isDynamic? @"dynamic part":@"static part", view.aktName, isDynamic? @"动态部分":@"静态部分"];
        NSString *sugget = [NSString stringWithFormat:@"> You add too much reference. For more details, please refer to the error message described in the document. 添加了过多的参照，详情请参考错误信息描述文档"];
        __aktErrorReporter(301, description, sugget);
        return;
    }
    // 存入布局数据
    AKTAttributeItemRef itemRef;
    if(isDynamic){
        itemRef = attributeRef_global->itemArrayForDynamic+attributeRef_global->itemCountForDynamic;
        aktAttributeItemInit(itemRef);
        attributeRef_global->itemCountForDynamic++;
        
    }else{
        itemRef = attributeRef_global->itemArrayForStatic+attributeRef_global->itemCountForStatic;
        aktAttributeItemInit(itemRef);
        attributeRef_global->itemCountForStatic++;
    }
    // Set bindView
    itemRef->bindView = attributeRef_global->bindView;
    // Add itemType to item
    itemRef->typeArray[itemRef->typeCount] = itemType;
    itemRef->typeCount++;
    return;
}

#pragma mark - function implementations
//|---------------------------------------------------------
/*
 * Calculate layout with the infor from the attribute items, return CGRect
 * Configurations in AKTLayoutParam, as follows configurations can be divided into vertical and horizontal direction
 * In one direction two configurations in addition to "whRatio" is enough to calculate the frame in that direction. WhRation will be convert to the configuration of width or height
 * ________________________________________
 * |    verticcal    |     horizontal     |
 * |       top       |        left        |
 * |      bottom     |        right       |
 * |      height     |        width       |
 * |     centerY     |       centerX      |
 * |    >whRatio<    |      >whRatio<     |
 * |_________________|____________________|
 */
CGRect calculateAttribute(AKTLayoutAttributeRef attributeRef, const void *referenceViewPtr) {
    UIView *bindView = (__bridge UIView *)(attributeRef->bindView);
    
    
    // Get dynamic layout info.
    bool validLayoutAttributeInfo = attributeRef->validLayoutAttributeInfo;
    // One of the view it referenced was dealloced.
    if (!validLayoutAttributeInfo) {
        NSString *description = [NSString stringWithFormat:@"> %@: One of the view it referenced was dealloced.\n> 某个参照的视图已经销毁", bindView.aktName];
        NSString *sugget = [NSString stringWithFormat:@"> For more details, please refer to the error message described in the document. 详情请参考错误信息描述文档"];
        __aktErrorReporter(205, description, sugget);
        return bindView.frame;
    }
    // 获取所有的参照视图
    if (attributeRef->layoutInfoTag>LONG_MAX-1) {// 是否是第一次进入计算
        getAllOfTheReferencedView(attributeRef, bindView);
    }
    
    if (attributeRef->blockCountForDynamic) {
        // 切换上下文
        AKTLayoutAttributeRef tempGlobal = attributeRef_global;
        attributeRef_global = attributeRef;
        // 查找符合条件的动态布局
        BOOL meetCondition = NO;
        for (int i=0; i<attributeRef->blockCountForDynamic; i++) {
            AKTDynamicLayoutBlock *block = attributeRef->blockArrayForDynamic+i;
            BOOL (^condition)() = (__bridge BOOL (^)())(block->conditionBlock);
            if (condition()) {
                meetCondition = YES;
                if (attributeRef->layoutInfoTag!=i) {// Layout info will be changed.
                    attributeRef->layoutInfoTag = i;
                    attributeRef->itemCountForDynamic = 0;
                    attributeRef->layoutDynamicContextBegin = true;
                    void(^attribute)(AKTLayoutShellAttribute *dynamicLayout) = (__bridge void (^)(AKTLayoutShellAttribute *dynamicLayout))(block->attributeBlock);
                    attribute(sharedShellAttribute());
                    attributeRef->layoutDynamicContextBegin = false;
                    attributeRef->currentLayoutInfoDidCheck = NO;
                    attributeRef->viewReferenced = 0;
                    break;
                }
            }
        }
        if (!meetCondition) {
            // 配置默认的tag，未找到合适的动态布局时.
            if (attributeRef->layoutInfoTag>=0) {
                attributeRef->itemCountForDynamic = 0;
                attributeRef->layoutInfoTag = -1;
            }
        }
        // 恢复上下文
        attributeRef_global = tempGlobal;
    }else{// 未配置动态布局
        if (attributeRef->layoutInfoTag>LONG_MAX-1) attributeRef->layoutInfoTag = -1;
    }
    
    
    // Filter out invalid layout items
    if (!attributeRef->currentLayoutInfoDidCheck) {
        //        if (attributeRef->itemCountForStatic == 0 && attributeRef->itemCountForDynamic == 0) {
        //            NSString *description = [NSString stringWithFormat:@"> %@: Not added any attribute items.\n> 未添加任何参照", bindView.aktName];
        //            NSString *sugget = [NSString stringWithFormat:@"> For more details, please refer to the error message described in the document. 详情请参考错误信息描述文档"];
        //            __aktErrorReporter(302, description, sugget);
        //            return bindView.frame;
        //        }
        // 去除动态信息中的无效布局信息，静态的已经移除过
        removeInvalidAttributeItemFromAttribute(attributeRef, true);
    }
    
    
    // Filter layout setting information.(size, whRatio, recalculation)
    // 过滤布局设置信息(size, whRatio, recalculation)
    AKTLayoutParam paramInfo = initializedParamInfo();
    int count = attributeRef->itemCountForStatic;
    BOOL isDynamic = NO;
    if (count==0) {
        // Switch to traverse the dynamic layout item.
        count = attributeRef->itemCountForDynamic;
        isDynamic = YES;
    }
    // For edge, if edge was setted ignore other settings and calculate frame with the edge.
    UIEdgeInsets edgeInset = UIEdgeInsetsMake(FLT_MAX, FLT_MAX, FLT_MAX, FLT_MAX);
    UIView *referenceViewEdge = nil;
    id globalSet = nil;
    NSMutableSet *set;
    if (!globalSet) {
        globalSet = [NSMutableSet set];
    }
    set = globalSet;
    [set removeAllObjects];
    for (int i = 0; i<count; i++) {
        AKTAttributeItemRef itemRef;
        if (isDynamic) {
            itemRef = attributeRef->itemArrayForDynamic+i;
        }else{
            itemRef = attributeRef->itemArrayForStatic+i;
        }
        
        
        // Save views referened by current view.
        if (!attributeRef->currentLayoutInfoDidCheck) {
            // Get layout reference view
            UIView *referenceView = nil;
            if(itemRef->configuration.reference.referenceType == AKTRefenceType_View) {
                referenceView = (__bridge UIView *)(itemRef->configuration.reference.referenceView);
                referenceViewEdge = referenceView;
                [set addObject:referenceView];
            }else if (itemRef->configuration.reference.referenceType == AKTRefenceType_ViewAttribute) {
                referenceView = (__bridge UIView *)(itemRef->configuration.reference.referenceAttribute.referenceView);
                [set addObject:referenceView];
            }
        }else{
            if(itemRef->configuration.reference.referenceType == AKTRefenceType_View) {
                referenceViewEdge = (__bridge UIView *)(itemRef->configuration.reference.referenceView);
            }
        }
        
        
        // Special handle the situation: set edge or size.
        // Get edge info and calculation the frame if the edge setting exist.
        edgeInset = itemRef->configuration.referenceEdgeInsert;
        if(edgeInset.top<FLT_MAX-1 && referenceViewEdge){
            return calculateRectWithEdgeFromAttribute(bindView, attributeRef, referenceViewEdge, itemRef, edgeInset, isDynamic);
        }
        
        
        // If we configured "equaltoSize", set the view's size directly.
        bool hasSize = false;
        setSizeIfExist(itemRef, &paramInfo, &hasSize);
        
        
        // Get whRatio if exist，According to the value of "whRatio" we'll calculation layout in different way.
        if (!hasSize) getWHRatio(itemRef, &paramInfo);
        // Switch to traverse the dynamic layout item.
        if (i==count-1 && !isDynamic) {
            count = attributeRef->itemCountForDynamic;
            i = -1;
            isDynamic = YES;
        }
    }
    
    if (!attributeRef->currentLayoutInfoDidCheck) {
        for (UIView *view in set) {
            // 保存到当前布局参照视图数组中
            if (view) {
                void **ptr = attributeRef->currentViewReferenced+attributeRef->viewReferenced;
                *ptr = (__bridge void *)(view);
                attributeRef->viewReferenced++;
            }
        }
        attributeRef->currentLayoutInfoDidCheck = true;
    }
    
    
    // Set other itemtypes: top/left/width.... into paramInfo
    count = attributeRef->itemCountForStatic;
    isDynamic = NO;
    if (count==0) {
        // Switch to traverse the dynamic layout item.
        count = attributeRef->itemCountForDynamic;
        isDynamic = YES;
    }
    for (int i = 0; i<count; i++) {
        AKTAttributeItemRef itemRef;
        if (isDynamic) {
            itemRef = attributeRef->itemArrayForDynamic+i;
        }else{
            itemRef = attributeRef->itemArrayForStatic+i;
        }
        parseItem(itemRef, &paramInfo, bindView);
        // Switch to traverse the dynamic layout item.
        if (i==count-1 && !isDynamic) {
            count = attributeRef->itemCountForDynamic;
            i = -1;
            isDynamic = YES;
        }
    }
    return calculateRect(&paramInfo, attributeRef);
}

void getAllOfTheReferencedView(AKTLayoutAttributeRef attributeRef, UIView *bindview) {
    removeInvalidAttributeItemFromAttribute(attributeRef, false);
    void (^block)(bool isDynamic) = ^(bool isDynamic){
        int count = isDynamic? attributeRef->itemCountForDynamic:attributeRef->itemCountForStatic;
        for (int i = 0; i<count; i++) {
            AKTAttributeItemRef itemRef;
            if (isDynamic) {
                itemRef = attributeRef->itemArrayForDynamic+i;
            }else{
                itemRef = attributeRef->itemArrayForStatic+i;
            }
            // Get layout reference view
            UIView *referenceView = nil;
            if(itemRef->configuration.reference.referenceType == AKTRefenceType_View) {
                referenceView = (__bridge UIView *)(itemRef->configuration.reference.referenceView);
                [referenceView.layoutChain addObject:bindview.aktContainer];
                [bindview.viewsReferenced addObject:referenceView.aktContainer];
            }else if (itemRef->configuration.reference.referenceType == AKTRefenceType_ViewAttribute) {
                referenceView = (__bridge UIView *)(itemRef->configuration.reference.referenceAttribute.referenceView);
                [referenceView.layoutChain addObject:bindview.aktContainer];
                [bindview.viewsReferenced addObject:referenceView.aktContainer];
            }
        }
    };
    block(false);
    for (int i=0; i<attributeRef->blockCountForDynamic; i++) {
        AKTDynamicLayoutBlock *layoutBlock = attributeRef->blockArrayForDynamic+i;
        void(^attributeBlock)(AKTLayoutShellAttribute *dynamicLayout) = (__bridge void (^)(AKTLayoutShellAttribute *dynamicLayout))(layoutBlock->attributeBlock);
        attributeRef->layoutDynamicContextBegin = true;
        attributeBlock(sharedShellAttribute());
        block(true);
        attributeRef->itemCountForDynamic = 0;
    }
    attributeRef->layoutDynamicContextBegin = false;
}

/**
 *  Remove invalid layout info.
 *
 *  @param attributeRef
 */
void removeInvalidAttributeItemFromAttribute(AKTLayoutAttributeRef attributeRef, bool fromDynamic) {
    int valideItemCount = 0;
    if (!fromDynamic) {
        for (int i = 0; i<attributeRef->itemCountForStatic; i++) {
            AKTAttributeItemRef itemRef = attributeRef->itemArrayForStatic+i;
            if (itemRef->configuration.reference.referenceValidate == false) {
                continue;
            }else{
                attributeRef->itemArrayForStatic[valideItemCount] = *itemRef;
                valideItemCount++;
            }
        }
        attributeRef->itemCountForStatic = valideItemCount;
    }else{
        valideItemCount = 0;
        for (int i = 0; i<attributeRef->itemCountForDynamic; i++) {
            AKTAttributeItemRef itemRef = attributeRef->itemArrayForDynamic+i;
            if (itemRef->configuration.reference.referenceValidate == false) {
                continue;
            }else{
                attributeRef->itemArrayForDynamic[valideItemCount] = *itemRef;
                valideItemCount++;
            }
        }
        attributeRef->itemCountForDynamic = valideItemCount;
    }
}

/**
 *  Calculate frame with edge.
 */
CGRect calculateRectWithEdgeFromAttribute(UIView *bindView, AKTLayoutAttributeRef attributeRef, UIView *referenceView, AKTAttributeItemRef itemRef, UIEdgeInsets edgeInset, BOOL isDynamic) {
    CGFloat x_i, y_i,w_i,h_i;
    CGRect viewRec = [bindView.superview convertRect:referenceView.frame fromView:referenceView.superview? referenceView.superview:mAKT_APPDELEGATE.keyWindow];
    x_i = viewRec.origin.x+calculate(edgeInset.left, itemRef->configuration.referenceMultiple,  itemRef->configuration.referenceCoefficientOffset, itemRef->configuration.referenceOffset);
    y_i = viewRec.origin.y+calculate(edgeInset.top, itemRef->configuration.referenceMultiple, itemRef->configuration.referenceCoefficientOffset, itemRef->configuration.referenceOffset);
    w_i = -calculate(edgeInset.left, itemRef->configuration.referenceMultiple, itemRef->configuration.referenceCoefficientOffset, itemRef->configuration.referenceOffset)+viewRec.size.width-calculate(edgeInset.right, itemRef->configuration.referenceMultiple, itemRef->configuration.referenceCoefficientOffset, itemRef->configuration.referenceOffset);
    h_i = -calculate(edgeInset.top, itemRef->configuration.referenceMultiple, itemRef->configuration.referenceCoefficientOffset, itemRef->configuration.referenceOffset)+viewRec.size.height-calculate(edgeInset.bottom, itemRef->configuration.referenceMultiple, itemRef->configuration.referenceCoefficientOffset, itemRef->configuration.referenceOffset);
    // If the layout info was not filtered.
    if (!attributeRef->currentLayoutInfoDidCheck) {
        // Optimization attribute Ref remove redundant layout info.
        if (isDynamic) {
            attributeRef->itemArrayForDynamic[0] = *itemRef;
            attributeRef->itemCountForDynamic = 1;
        }else{
            attributeRef->itemArrayForStatic[0] = *itemRef;
            attributeRef->itemCountForStatic = 1;
            attributeRef->itemCountForDynamic = 0;
        }
        // 将当前视图添加到参照视图的布局更新链数组中,
        // 同时将参照视图添加到当前视图的视图参照视图数组中。
        [referenceView.layoutChain addObject:bindView.aktContainer];
        [bindView.viewsReferenced addObject:referenceView.aktContainer];
        attributeRef->currentLayoutInfoDidCheck = true;
    }
    return CGRectMake(x_i, y_i, w_i, h_i);
}

void getWHRatio(AKTAttributeItemRef itemRef, AKTLayoutParamRef paramRef) {
    for (int j = 0; j<itemRef->typeCount; j++) {
        int num = itemRef->typeArray[j];
        if (num == AKTAttributeItemType_WHRatio) {
            if (itemRef->configuration.reference.referenceType == AKTRefenceType_Constant) {
                paramRef->whRatio = itemRef->configuration.reference.referenceValue;
            }else{
                UIView *v = (__bridge UIView *)(itemRef->configuration.reference.referenceView);
                paramRef->whRatio = calculate(v.width/v.height, itemRef->configuration.referenceMultiple, itemRef->configuration.referenceCoefficientOffset, itemRef->configuration.referenceOffset);
            }
        }
    }
}

void setSizeIfExist(AKTAttributeItemRef itemRef, AKTLayoutParamRef paramRef, bool *hasSize) {
    CGSize size = itemRef->configuration.reference.referenceSize;
    if(size.width<FLT_MAX-1) {
        if (itemRef->configuration.reference.referenceType == AKTRefenceType_View) {
            UIView *referenceView = (__bridge UIView *)(itemRef->configuration.reference.referenceView);
            itemRef->configuration.reference.referenceSize = referenceView.frame.size;
        }
        size = itemRef->configuration.reference.referenceSize;
        paramRef->width = calculate(size.width, itemRef->configuration.referenceMultiple, itemRef->configuration.referenceCoefficientOffset, itemRef->configuration.referenceOffset);
        paramRef->height = calculate(size.height, itemRef->configuration.referenceMultiple, itemRef->configuration.referenceCoefficientOffset, itemRef->configuration.referenceOffset);
        *hasSize = true;
    }
}

#pragma mark - for frame calculation
//|---------------------------------------------------------
/*
 * Parse layout item to layout param
 */
void parseItem(AKTAttributeItemRef itemRef, AKTLayoutParamRef paramRef, UIView *bindView) {
    // All of the layout types in the array
    for (int i = 0; i<itemRef->typeCount; i++) {
        int num = itemRef->typeArray[i];
        // If we configured other position constraints do different treatment by differentiating the reference type of constraints.
        // 如果设置了其它的位置约束, 通过区分约束参考类型来做不同的处理
        if (itemRef->configuration.reference.referenceType == AKTRefenceType_Constant) {
            float result = calculate(itemRef->configuration.reference.referenceValue, itemRef->configuration.referenceMultiple, itemRef->configuration.referenceCoefficientOffset, itemRef->configuration.referenceOffset);
            switch (itemRef->typeArray[i]) {
                case AKTAttributeItemType_Top:
                {
                    paramRef->top = result;
                    break;
                }
                case AKTAttributeItemType_Left:
                {
                    paramRef->left = result;
                    break;
                }
                case AKTAttributeItemType_Bottom:
                {
                    paramRef->bottom = result;
                    break;
                }
                case AKTAttributeItemType_Right:
                {
                    paramRef->right = result;
                    break;
                }
                case AKTAttributeItemType_Width:
                {
                    if (paramRef->width<FLT_MAX-1 && !mAKT_EQ(paramRef->width, result)) {
                        UIView *bindView = (__bridge UIView *)(itemRef->bindView);
                        NSString *description = [NSString stringWithFormat:@"> %@: Has redundant configuration: width.\n> 定义了多余参照：width", bindView.aktName];
                        NSString *sugget = [NSString stringWithFormat:@"> Remove unnecessary reference. For more details, please refer to the error message described in the document. 删除不必要的参照，详情请参考错误信息描述文档"];
                        __aktErrorReporter(204, description, sugget);
                    }
                    paramRef->width = result;
                    break;
                }
                case AKTAttributeItemType_Height:
                {
                    if (paramRef->height<FLT_MAX-1 && !mAKT_EQ(paramRef->height, result)) {
                        UIView *bindView = (__bridge UIView *)(itemRef->bindView);
                        NSString *description = [NSString stringWithFormat:@"> %@: Has redundant configuration: height.\n> 定义了多余参照：height", bindView.aktName];
                        NSString *sugget = [NSString stringWithFormat:@"> Remove unnecessary reference. For more details, please refer to the error message described in the document. 删除不必要的参照，详情请参考错误信息描述文档"];
                        __aktErrorReporter(204, description, sugget);
                    }
                    paramRef->height = result;
                    break;
                }
                case AKTAttributeItemType_CenterX:
                {
                    paramRef->centerX = result;
                    break;
                }
                case AKTAttributeItemType_CenterY:
                {
                    paramRef->centerY = result;
                    break;
                }
                case AKTAttributeItemType_CenterXY:
                {
                    paramRef->centerY = paramRef->centerX = result;
                    break;
                }
                default:
                    break;
            }
        }else if(itemRef->configuration.reference.referenceType == AKTRefenceType_View){
            UIView *v = (__bridge UIView *)(itemRef->configuration.reference.referenceView);
            CGRect viewRec = [bindView.superview convertRect:v.frame fromView:v.superview? v.superview:mAKT_APPDELEGATE.keyWindow];
            switch (num) {
                case AKTAttributeItemType_Top:
                {
                    paramRef->top = calculate(viewRec.origin.y, itemRef->configuration.referenceMultiple, itemRef->configuration.referenceCoefficientOffset, itemRef->configuration.referenceOffset);
                    break;
                }
                case AKTAttributeItemType_Left:
                {
                    paramRef->left = calculate(viewRec.origin.x, itemRef->configuration.referenceMultiple, itemRef->configuration.referenceCoefficientOffset, itemRef->configuration.referenceOffset);
                    break;
                }
                case AKTAttributeItemType_Bottom:
                {
                    paramRef->bottom = calculate(viewRec.origin.y+viewRec.size.height, itemRef->configuration.referenceMultiple, itemRef->configuration.referenceCoefficientOffset, itemRef->configuration.referenceOffset);
                    break;
                }
                case AKTAttributeItemType_Right:
                {
                    paramRef->right = calculate(viewRec.origin.x+viewRec.size.width, itemRef->configuration.referenceMultiple, itemRef->configuration.referenceCoefficientOffset, itemRef->configuration.referenceOffset);
                    break;
                }
                case AKTAttributeItemType_Width:
                {
                    CGFloat result = calculate(viewRec.size.width, itemRef->configuration.referenceMultiple, itemRef->configuration.referenceCoefficientOffset, itemRef->configuration.referenceOffset);
                    if (paramRef->width<FLT_MAX-1 && !mAKT_EQ(paramRef->width, result)) {
                        UIView *bindView = (__bridge UIView *)(itemRef->bindView);
                        NSString *description = [NSString stringWithFormat:@"> %@: Has redundant configuration: width.\n> 定义了多余参照：width", bindView.aktName];
                        NSString *sugget = [NSString stringWithFormat:@"> Remove unnecessary reference. For more details, please refer to the error message described in the document. 删除不必要的参照，详情请参考错误信息描述文档"];
                        __aktErrorReporter(204, description, sugget);
                    }
                    paramRef->width = result;
                    
                    break;
                }
                case AKTAttributeItemType_Height:
                {
                    CGFloat result = calculate(viewRec.size.height, itemRef->configuration.referenceMultiple, itemRef->configuration.referenceCoefficientOffset, itemRef->configuration.referenceOffset);
                    if (paramRef->height<FLT_MAX-1 && !mAKT_EQ(paramRef->height, result)) {
                        UIView *bindView = (__bridge UIView *)(itemRef->bindView);
                        NSString *description = [NSString stringWithFormat:@"> %@: Has redundant configuration: height.\n> 定义了多余参照：height", bindView.aktName];
                        NSString *sugget = [NSString stringWithFormat:@"> Remove unnecessary reference. For more details, please refer to the error message described in the document. 删除不必要的参照，详情请参考错误信息描述文档"];
                        __aktErrorReporter(204, description, sugget);
                    }
                    paramRef->height = result;
                    break;
                }
                case AKTAttributeItemType_CenterX:
                {
                    paramRef->centerX = calculate(viewRec.origin.x+viewRec.size.width/2, itemRef->configuration.referenceMultiple, itemRef->configuration.referenceCoefficientOffset, itemRef->configuration.referenceOffset);
                    break;
                }
                case AKTAttributeItemType_CenterY:
                {
                    paramRef->centerY = calculate(viewRec.origin.y+viewRec.size.height/2, itemRef->configuration.referenceMultiple, itemRef->configuration.referenceCoefficientOffset, itemRef->configuration.referenceOffset);
                    break;
                }
                case AKTAttributeItemType_CenterXY:
                {
                    paramRef->centerX = calculate(viewRec.origin.x+viewRec.size.width/2, itemRef->configuration.referenceMultiple, itemRef->configuration.referenceCoefficientOffset, itemRef->configuration.referenceOffset);
                    paramRef->centerY = calculate(viewRec.origin.y+viewRec.size.height/2, itemRef->configuration.referenceMultiple, itemRef->configuration.referenceCoefficientOffset, itemRef->configuration.referenceOffset);
                    break;
                }
                default:
                    break;
            }
        }else{
            float result = getValue(itemRef->configuration.reference.referenceAttribute, bindView);
            result = calculate(result, itemRef->configuration.referenceMultiple, itemRef->configuration.referenceCoefficientOffset, itemRef->configuration.referenceOffset);
            switch (num) {
                case AKTAttributeItemType_Top:
                {
                    paramRef->top = result;
                    break;
                }
                case AKTAttributeItemType_Left:
                {
                    paramRef->left = result;
                    break;
                }
                case AKTAttributeItemType_Bottom:
                {
                    paramRef->bottom = result;
                    break;
                }
                case AKTAttributeItemType_Right:
                {
                    paramRef->right = result;
                    break;
                }
                case AKTAttributeItemType_Width:
                {
                    if (paramRef->width<FLT_MAX-1 && !mAKT_EQ(paramRef->width, result)) {
                        NSString *description = [NSString stringWithFormat:@"> %@: Has redundant configuration: width.\n> 定义了多余参照：width", bindView.aktName];
                        NSString *sugget = [NSString stringWithFormat:@"> Remove unnecessary reference. For more details, please refer to the error message described in the document. 删除不必要的参照，详情请参考错误信息描述文档"];
                        __aktErrorReporter(204, description, sugget);
                    }
                    paramRef->width = result;
                    break;
                }
                case AKTAttributeItemType_Height:
                {
                    if (paramRef->height<FLT_MAX-1 && !mAKT_EQ(paramRef->height, result)) {
                        NSString *description = [NSString stringWithFormat:@"> %@: Has redundant configuration: height.\n> 定义了多余参照：height", bindView.aktName];
                        NSString *sugget = [NSString stringWithFormat:@"> Remove unnecessary reference. For more details, please refer to the error message described in the document. 删除不必要的参照，详情请参考错误信息描述文档"];
                        __aktErrorReporter(204, description, sugget);
                    }
                    paramRef->height = result;
                    break;
                }
                case AKTAttributeItemType_CenterX:
                {
                    paramRef->centerX = result;
                    break;
                }
                case AKTAttributeItemType_CenterY:
                {
                    paramRef->centerY = result;
                    break;
                }
                case AKTAttributeItemType_CenterXY:
                {
                    paramRef->centerY = paramRef->centerX = result;
                    break;
                }
                default:
                    break;
            }
        }
    }
}

/*
 * Rect generated by infor in param
 */
CGRect calculateRect(AKTLayoutParamRef paramRef, AKTLayoutAttributeRef attributeRef) {
    CGRect rect;
    // The following are calculation methods
    // whether whRatio is available
    if (paramRef->whRatio<FLT_MAX) {
        rect = rectWhRatio(paramRef, attributeRef);
    }else{
        rect = rectNoWhRatio(paramRef, attributeRef);
    }
    return rect;
}

/*
 * According to param, calculate the size of frame in horizontal direction. When you call the method, please ensure there were no redundant configurations in param.
 * In one direction two configurations in addition to "whRatio" is enough to calculate the frame in that direction. WhRation will be convert to the configuration of width or height
 * @oRect : The frame of the view which will be layout according to the reference view was got before layout
 */
CGRect horizontalCalculation(AKTLayoutParamRef paramRef, CGRect oRect) {
    CGFloat x, y, width, height;
    x = oRect.origin.x;
    y = oRect.origin.y;
    width = oRect.size.width;
    height = oRect.size.height;
    if (paramRef->centerX<FLT_MAX) {
        if (paramRef->left<FLT_MAX) {
            x = paramRef->left;
            width = (paramRef->centerX-x)*2;
        }else if (paramRef->right<FLT_MAX) {
            x = paramRef->centerX-(paramRef->right-paramRef->centerX);
            width = (paramRef->right-paramRef->centerX)*2;
        }else if (paramRef->width<FLT_MAX) {
            x = paramRef->centerX-paramRef->width/2;
            width = paramRef->width;
        }else if (paramRef->centerX<FLT_MAX) {
            x = paramRef->centerX-width/2;
        }
    }else{
        if (paramRef->left<FLT_MAX) {
            x = paramRef->left;
            if (paramRef->width<FLT_MAX) {
                width = paramRef->width;
            }
            if (paramRef->right<FLT_MAX) {
                width = paramRef->right - x;
            }
        }else{
            if (paramRef->width<FLT_MAX) {
                width = paramRef->width;
            }
            if (paramRef->right<FLT_MAX) {
                x = paramRef->right-width;
            }
        }
    }
    return  CGRectMake(x, y, width, height);
}

/*
 * According to param, calculate the size of frame in vertical direction. When you call the method, please ensure there were no redundant configurations in param.
 * In one direction two configurations in addition to "whRatio" is enough to calculate the frame in that direction. WhRation will be convert to the configuration of width or height
 * @oRect : The frame of the view which will be layout according to the reference view was got before layout
 */
CGRect verticalCalculation(AKTLayoutParamRef paramRef, CGRect oRect) {
    CGFloat x, y, width, height;
    x = oRect.origin.x;
    y = oRect.origin.y;
    width = oRect.size.width;
    height = oRect.size.height;
    if (paramRef->centerY<FLT_MAX) {
        if (paramRef->top<FLT_MAX) {
            y = paramRef->top;
            height = (paramRef->centerY-y)*2;
        }else if (paramRef->bottom<FLT_MAX) {
            y = paramRef->centerY-(paramRef->bottom-paramRef->centerY);
            height = (paramRef->bottom-paramRef->centerY)*2;
        }else if (paramRef->height<FLT_MAX) {
            y = paramRef->centerY-paramRef->height/2;
            height = paramRef->height;
        }else if (paramRef->centerY<FLT_MAX) {
            y = paramRef->centerY-height/2;
        }
    }else{
        if (paramRef->top<FLT_MAX) {
            y = paramRef->top;
            if (paramRef->height<FLT_MAX) {
                height = paramRef->height;
            }
            if (paramRef->bottom<FLT_MAX) {
                height = paramRef->bottom - y;
            }
        }else{
            if (paramRef->height<FLT_MAX) {
                height = paramRef->height;
            }
            if (paramRef->bottom<FLT_MAX) {
                y = paramRef->bottom-height;
            }
        }
    }
    return  CGRectMake(x, y, width, height);
}

/*
 * The param has no configuration for whRatio, return the rect
 */
CGRect rectNoWhRatio(AKTLayoutParamRef paramRef, AKTLayoutAttributeRef attributeRef) {
    UIView *bindView = (__bridge UIView *)(attributeRef->bindView);
    CGRect rect = bindView.frame;
    // Block for checking and removing redundant configurations in horizontal direction
    int (^CheckConfigurationInNoRatio_Horizontal)() = ^int(){
        int hCount = 0;
        if (paramRef->left<FLT_MAX) {
            hCount++;
        }
        if (paramRef->right<FLT_MAX) {
            hCount++;
            if (hCount>2) {
                paramRef->right = FLT_MAX;
                hCount--;
                NSString *description = [NSString stringWithFormat:@"> %@: Has redundant configuration: right.\n> 定义了多余参照：right", bindView.aktName];
                NSString *sugget = [NSString stringWithFormat:@"> Remove unnecessary reference. For more details, please refer to the error message described in the document. 删除不必要的参照，详情请参考错误信息描述文档"];
                __aktErrorReporter(204, description, sugget);
            }
        }
        if (paramRef->width<FLT_MAX) {
            hCount++;
            if (hCount>2) {
                paramRef->width = FLT_MAX;
                hCount--;
                NSString *description = [NSString stringWithFormat:@"> %@: Has redundant configuration: width.\n> 定义了多余参照：width", bindView.aktName];
                NSString *sugget = [NSString stringWithFormat:@"> Remove unnecessary reference. For more details, please refer to the error message described in the document. 删除不必要的参照，详情请参考错误信息描述文档"];
                __aktErrorReporter(204, description, sugget);
            }
        }
        if (paramRef->centerX<FLT_MAX) {
            hCount++;
            if (hCount>2) {
                paramRef->centerX = FLT_MAX;
                hCount--;
                NSString *description = [NSString stringWithFormat:@"> %@: Has redundant configuration: centerX.\n> 定义了多余参照：centerX", bindView.aktName];
                NSString *sugget = [NSString stringWithFormat:@"> Remove unnecessary reference. For more details, please refer to the error message described in the document. 删除不必要的参照，详情请参考错误信息描述文档"];
                __aktErrorReporter(204, description, sugget);
            }
        }
        return hCount;
    };
    // Block for checking and removing redundant configurations in vertical direction
    int (^CheckConfigurationInNoRatio_Vertical)() = ^int(){
        int vCount = 0;
        if (paramRef->top<FLT_MAX) {
            vCount++;
        }
        if (paramRef->bottom<FLT_MAX) {
            vCount++;
            if (vCount>2) {
                paramRef->bottom = FLT_MAX;
                vCount--;
                NSString *description = [NSString stringWithFormat:@"> %@: Has redundant configuration: bottom.\n> 定义了多余参照：bottom", bindView.aktName];
                NSString *sugget = [NSString stringWithFormat:@"> Remove unnecessary reference. For more details, please refer to the error message described in the document. 删除不必要的参照，详情请参考错误信息描述文档"];
                __aktErrorReporter(204, description, sugget);
            }
        }
        if (paramRef->height<FLT_MAX) {
            vCount++;
            bindView.adaptiveHeight = @NO;
            if (vCount>2) {
                paramRef->height = FLT_MAX;
                vCount--;
                NSString *description = [NSString stringWithFormat:@"> %@: Has redundant configuration: height.\n> 定义了多余参照：height", bindView.aktName];
                NSString *sugget = [NSString stringWithFormat:@"> Remove unnecessary reference. For more details, please refer to the error message described in the document. 删除不必要的参照，详情请参考错误信息描述文档"];
                __aktErrorReporter(204, description, sugget);
            }
        }
        if (paramRef->centerY<FLT_MAX) {
            vCount++;
            if (vCount>2) {
                paramRef->centerY = FLT_MAX;
                vCount--;
                NSString *description = [NSString stringWithFormat:@"> %@: Has redundant configuration: centerY.\n> 定义了多余参照：centerY", bindView.aktName];
                NSString *sugget = [NSString stringWithFormat:@"> Remove unnecessary reference. For more details, please refer to the error message described in the document. 删除不必要的参照，详情请参考错误信息描述文档"];
                __aktErrorReporter(204, description, sugget);
            }
        }
        return vCount;
    };
    // Calculate the size of the frame in the horizontal & vertical direction, specially centerX & centerY get priority to meet
    // Check redundant configuration, if found report it
    // Redundant configurations will be abandoned after perform the following operations, otherwise a lack of configurations
    int horizonCount = CheckConfigurationInNoRatio_Horizontal();
    // Set view's height adaptive
    if (horizonCount == 2 || paramRef->width<FLT_MAX) {
        bindView.adaptiveWidth = @NO;
    }else{
        bindView.adaptiveWidth = @YES;
    }
    rect = horizontalCalculation(paramRef, rect);
    int verticalCount = CheckConfigurationInNoRatio_Vertical();
    // Set view's width adaptive
    if (verticalCount == 2 || paramRef->height<FLT_MAX) {
        bindView.adaptiveHeight = @NO;
    }else{
        bindView.adaptiveHeight = @YES;
    }
    rect = verticalCalculation(paramRef, rect);
    return rect;
}

/*
 * The param has the configuration for whRatio, return the rect
 */
CGRect rectWhRatio(AKTLayoutParamRef paramRef, AKTLayoutAttributeRef attributeRef) {
    UIView *bindView = (__bridge UIView *)(attributeRef->bindView);
    __block CGRect rect = bindView.frame;
    // Block for checking and removing redundant configurations in horizontal direction
    int (^CheckConfigurationInRatio_Horizontal)() = ^int(){
        int hCount = 0;
        if (paramRef->left<FLT_MAX) {
            hCount++;
        }
        if (paramRef->right<FLT_MAX) {
            hCount++;
            if (hCount>2) {
                paramRef->right = FLT_MAX;
                hCount--;
                NSString *description = [NSString stringWithFormat:@"> %@: Has redundant configuration: right.\n> 定义了多余参照：right", bindView.aktName];
                NSString *sugget = [NSString stringWithFormat:@"> Remove unnecessary reference. For more details, please refer to the error message described in the document. 删除不必要的参照，详情请参考错误信息描述文档"];
                __aktErrorReporter(204, description, sugget);
            }
        }
        if (paramRef->width<FLT_MAX) {
            hCount++;
            bindView.adaptiveWidth = @NO;
            if (hCount>2) {
                paramRef->width = FLT_MAX;
                hCount--;
                NSString *description = [NSString stringWithFormat:@"> %@: Has redundant configuration: width.\n> 定义了多余参照：width", bindView.aktName];
                NSString *sugget = [NSString stringWithFormat:@"> Remove unnecessary reference. For more details, please refer to the error message described in the document. 删除不必要的参照，详情请参考错误信息描述文档"];
                __aktErrorReporter(204, description, sugget);
            }
        }
        if (paramRef->centerX<FLT_MAX) {
            hCount++;
            if (hCount>2) {
                paramRef->centerX = FLT_MAX;
                hCount--;
                NSString *description = [NSString stringWithFormat:@"> %@: Has redundant configuration: centerX.\n> 定义了多余参照：centerX", bindView.aktName];
                NSString *sugget = [NSString stringWithFormat:@"> Remove unnecessary reference. For more details, please refer to the error message described in the document. 删除不必要的参照，详情请参考错误信息描述文档"];
                __aktErrorReporter(204, description, sugget);
            }
        }
        return hCount;
    };
    // Block for checking and removing redundant configurations in vertical direction
    int (^CheckConfigurationInRatio_Vertical)() = ^int(){
        int vCount = 0;
        if (paramRef->top<FLT_MAX) {
            vCount++;
        }
        if (paramRef->bottom<FLT_MAX) {
            vCount++;
            if (vCount>2) {
                paramRef->bottom = FLT_MAX;
                vCount--;
                NSString *description = [NSString stringWithFormat:@"> %@: Has redundant configuration: bottom.\n> 定义了多余参照：bottom", bindView.aktName];
                NSString *sugget = [NSString stringWithFormat:@"> Remove unnecessary reference. For more details, please refer to the error message described in the document. 删除不必要的参照，详情请参考错误信息描述文档"];
                __aktErrorReporter(204, description, sugget);
            }
        }
        if (paramRef->height<FLT_MAX) {
            vCount++;
            bindView.adaptiveHeight = @NO;
            if (vCount>2) {
                paramRef->height = FLT_MAX;
                vCount--;
                NSString *description = [NSString stringWithFormat:@"> %@: Has redundant configuration: height.\n> 定义了多余参照：height", bindView.aktName];
                NSString *sugget = [NSString stringWithFormat:@"> Remove unnecessary reference. For more details, please refer to the error message described in the document. 删除不必要的参照，详情请参考错误信息描述文档"];
                __aktErrorReporter(204, description, sugget);
            }
        }
        if (paramRef->centerY<FLT_MAX) {
            vCount++;
            if (vCount>2) {
                paramRef->centerY = FLT_MAX;
                vCount--;
                NSString *description = [NSString stringWithFormat:@"> %@: Has redundant configuration: centerY.\n> 定义了多余参照：centerY", bindView.aktName];
                NSString *sugget = [NSString stringWithFormat:@"> Remove unnecessary reference. For more details, please refer to the error message described in the document. 删除不必要的参照，详情请参考错误信息描述文档"];
                __aktErrorReporter(204, description, sugget);
            }
        }
        return vCount;
    };
    // The result of vertical and horizontal checking, count == 2 means that the configurations were enough,
    // count < 2 means less configuration
    int hCount = 0, vCount = 0;
    hCount = CheckConfigurationInRatio_Horizontal();
    vCount = CheckConfigurationInRatio_Vertical();
    void (^CalculateSum0)() = ^() {
        paramRef->height = rect.size.width/paramRef->whRatio;
        rect = verticalCalculation(paramRef, rect);
        bindView.adaptiveWidth = bindView.adaptiveHeight = @YES;
    };
    void (^CalculateSum1)() = ^() {
        if (hCount == 1) {
            rect = horizontalCalculation(paramRef, rect);
            paramRef->height = rect.size.width/paramRef->whRatio;
            rect = verticalCalculation(paramRef, rect);
        }else{
            rect = verticalCalculation(paramRef, rect);
            paramRef->width = rect.size.height*paramRef->whRatio;
            rect = horizontalCalculation(paramRef, rect);
        }
        if (paramRef->width<FLT_MAX || paramRef->height<FLT_MAX) {
            bindView.adaptiveWidth = bindView.adaptiveHeight = @NO;
        }else{
            bindView.adaptiveWidth = bindView.adaptiveHeight = @YES;
        }
    };
    void (^CalculateSum2)() = ^() {
        if (hCount == 0) {
            rect = verticalCalculation(paramRef, rect);
            // vCount = 2, hCount = 0 and whRatio is existing means that the view's width and height can't be adaptive.
            bindView.adaptiveWidth = bindView.adaptiveHeight = @NO;
            paramRef->width = rect.size.height*paramRef->whRatio;
            rect = horizontalCalculation(paramRef, rect);
        }else if (hCount == 1) {
            // 定义了高度并未定义宽度
            if(paramRef->height<FLT_MAX-1 && paramRef->width>=FLT_MAX-1) {
                rect = verticalCalculation(paramRef, rect);
                // vCount = 2, hCount = 0 and whRatio is existing means that the view's width and height can't be adaptive.
                bindView.adaptiveWidth = bindView.adaptiveHeight = @NO;
                paramRef->width = rect.size.height*paramRef->whRatio;
                rect = horizontalCalculation(paramRef, rect);
            }else{
                rect = horizontalCalculation(paramRef, rect);
                bindView.adaptiveWidth = paramRef->width<FLT_MAX-1? @NO:@YES;
                bindView.adaptiveHeight = @NO;
                if (paramRef->height<FLT_MAX-1) {
                    NSString *description = [NSString stringWithFormat:@"> %@: Has redundant configuration: whRatio.\n> 定义了多余参照：whRatio", bindView.aktName];
                    NSString *sugget = [NSString stringWithFormat:@"> Remove unnecessary reference. For more details, please refer to the error message described in the document. 删除不必要的参照，详情请参考错误信息描述文档"];
                    __aktErrorReporter(204, description, sugget);
                }else{
                    paramRef->height = rect.size.width/paramRef->whRatio;
                }
                rect = verticalCalculation(paramRef, rect);
            }
        }else if (hCount == 2) {
            rect = horizontalCalculation(paramRef, rect);
            // vCount = 0, hCount = 2 and whRatio is existing means that the view's width and height can't be adaptive.
            bindView.adaptiveWidth = bindView.adaptiveHeight = @NO;
            paramRef->height = rect.size.width/paramRef->whRatio;
            rect = verticalCalculation(paramRef, rect);
        }
    };
    void (^CalculateSum3)() = ^() {
        // vCount + hCount = 3 and whRatio is existing means that the view's width and height can't be adaptive.
        bindView.adaptiveWidth = bindView.adaptiveHeight = @NO;
        if (hCount == 1) {
            rect = verticalCalculation(paramRef, rect);
            if (paramRef->width<FLT_MAX-1) {
                NSString *description = [NSString stringWithFormat:@"> %@: Has redundant configuration: whRatio.\n> 定义了多余参照：whRatio", bindView.aktName];
                NSString *sugget = [NSString stringWithFormat:@"> Remove unnecessary reference. For more details, please refer to the error message described in the document. 删除不必要的参照，详情请参考错误信息描述文档"];
                __aktErrorReporter(204, description, sugget);
            }else{
                paramRef->width = rect.size.height*paramRef->whRatio;
            }
            rect = horizontalCalculation(paramRef, rect);
        }else if (hCount == 2) {
            rect = horizontalCalculation(paramRef, rect);
            if (paramRef->height<FLT_MAX-1) {
                NSString *description = [NSString stringWithFormat:@"> %@: Has redundant configuration: whRatio.\n> 定义了多余参照：whRatio", bindView.aktName];
                NSString *sugget = [NSString stringWithFormat:@"> Remove unnecessary reference. For more details, please refer to the error message described in the document. 删除不必要的参照，详情请参考错误信息描述文档"];
                __aktErrorReporter(204, description, sugget);
            }else{
                paramRef->height = rect.size.width/paramRef->whRatio;
            }
            rect = verticalCalculation(paramRef, rect);
        }
    };
    void (^CalculateSum4)() = ^() {
        // vCount + hCount = 4 and whRatio is existing means that the view's width and height can't be adaptive.
        bindView.adaptiveWidth = bindView.adaptiveHeight = @NO;
        rect = horizontalCalculation(paramRef, rect);
        rect = verticalCalculation(paramRef, rect);
        int currentRatio = rect.size.width/rect.size.height;
        int whRatio = paramRef->whRatio;
        if (!mAKT_EQ(currentRatio, whRatio)) {
            NSString *description = [NSString stringWithFormat:@"> %@: Has redundant configuration: whRatio.\n> 定义了多余参照：whRatio", bindView.aktName];
            NSString *sugget = [NSString stringWithFormat:@"> Remove unnecessary reference. For more details, please refer to the error message described in the document. 删除不必要的参照，详情请参考错误信息描述文档"];
            __aktErrorReporter(204, description, sugget);
        }
    };
    switch (hCount+vCount) {
        case 0:// vertical & horizontal had no configuration
        {
            CalculateSum0();
            break;
        }
        case 1:// vertical or horizontal had one configuration
        {
            CalculateSum1();
            break;
        }
        case 2:// vertical & horizontal will be 1+1 or 0+2 or 2+0
        {
            CalculateSum2();
            break;
        }
        case 3:// vertical & horizontal will be 1+2 or 2+1
        {
            CalculateSum3();
            break;
        }
        case 4:// vertical & horizontal will be 2+2
        {
            CalculateSum4();
            break;
        }
        default:
            break;
    }
    return rect;
}
